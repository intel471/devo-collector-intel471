import logging
from datetime import datetime, timedelta, timezone

from devocollectorsdk.inputs.collector_puller_abstract import CollectorPullerAbstract
from devocollectorsdk.message.lookup_job_factory import LookupJobFactory
from titan_client.models import IndicatorSearchSchema

# noinspection PyUnresolvedReferences
from agent.modules.intel471_malware_intel.intel471_indicators_puller_setup import Intel471IndicatorsPullerSetup
from agent.modules.intel471_malware_intel.exceptions.exceptions import *

log = logging.getLogger(__name__)

logging.getLogger('intel471_indicators_puller').setLevel(logging.WARNING)


class Intel471IndicatorsPuller(CollectorPullerAbstract):

    def init_variables(
            self,
            input_config: dict,
            input_definition: dict,
            service_config: dict,
            service_definition: dict,
            module_config: dict,
            module_definition: dict,
            submodule_config: dict):
        """

        :param input_config:
        :param input_definition:
        :param service_config:
        :param service_definition:
        :param module_config:
        :param module_definition:
        :param submodule_config:
        :return:
        """

        self.log_debug(f'{self.name} Starting the execution of init_variables()')

        # Initialization of properties from credentials section from configuration
        credentials: dict[str, str] = input_config.get('credentials')
        if credentials is None:
            raise CredentialException(1, f'Missing required "credentials" section in the configuration')

        username: str = credentials.get('username')
        if username is None:
            raise CredentialException(2, f'Missing required "username" property from "credentials" section in configuration')
        self.collector_variables['username'] = username

        password: str = credentials.get('password')
        if password is None:
            raise CredentialException(3,'Missing required "password" property from "credentials" section in configuration')
        self.collector_variables['password'] = password

        parameters: dict[str, int] = input_config.get('parameters')
        duration: int = parameters.get('duration')
        self.collector_variables['api_params']: dict = {
            'count': 100,
            '_from': self.get_from_timestamp(duration),
        }

        base_headers: list[str] = [
            'uid',
            'first_seen',
            'last_seen',
            'indicator_type',
            'context',
            'malware_family',
            'malware_family_version',
            'malware_family_variant',
            'expiration',
            'confidence',
            'mitre_tactics',
            'gir'
        ]

        self.collector_variables['file_lookup_headers']: list[str] = base_headers + [
            'download_url',
            'md5',
            'sha1',
            'sha256',
            'ssdeep',
            'size',
            'type'
        ]
        self.collector_variables['file_lookup_field_types']: list[str] = ['str'] * len(self.collector_variables['file_lookup_headers'])

        self.collector_variables['ipv4_lookup_headers']: list[str] = base_headers + [
            'ip_address',
            'isp',
            'city',
            'country'
        ]
        self.collector_variables['ipv4_lookup_field_types']: list[str] = ['str'] * len(self.collector_variables['ipv4_lookup_headers'])
        self.collector_variables['ipv4_lookup_field_types'][len(base_headers)] = 'ip4'  # set ip_address field type to ip4

        self.collector_variables['url_lookup_headers']: list[str] = base_headers + ['url']
        self.collector_variables['url_lookup_field_types']: list[str] = ['str'] * len(self.collector_variables['url_lookup_headers'])

        self.collector_variables['lookup_key']: str = 'uid'
        self.collector_variables['lookup_status']: str = None

        self.log_debug(f'{self.name} Finalizing the execution of init_variables()')

    def pre_pull(self, retrieving_timestamp: datetime):
        """
        :param retrieving_timestamp:
        :return:
        """

        log.info('[pre_pull] -> Creating relevant lookup_job_factory to be used by the pull method')

        file_lookup_table: LookupJobFactory = LookupJobFactory(
            lookup_name='malware_file_indicators',
            headers=self.collector_variables['file_lookup_headers'],
            field_types=self.collector_variables['file_lookup_field_types'],
            key=self.collector_variables['lookup_key'],
            historic_tag=self.collector_variables['lookup_status']
        )

        ipv4_lookup_table: LookupJobFactory = LookupJobFactory(
            lookup_name='malware_ipv4_indicators',
            headers=self.collector_variables['ipv4_lookup_headers'],
            field_types=self.collector_variables['ipv4_lookup_field_types'],
            key=self.collector_variables['lookup_key'],
            historic_tag=self.collector_variables['lookup_status']
        )

        url_lookup_table: LookupJobFactory = LookupJobFactory(
            lookup_name='malware_url_indicators',
            headers=self.collector_variables['url_lookup_headers'],
            field_types=self.collector_variables['url_lookup_field_types'],
            key=self.collector_variables['lookup_key'],
            historic_tag=self.collector_variables['lookup_status']
        )

        self.collector_variables['lookup_tables'] = {
            'file': file_lookup_table,
            'ipv4': ipv4_lookup_table,
            'url': url_lookup_table,
        }

        previous_state = self.persistence_object.load_state(no_log_traces=True)
        if previous_state:
            self.collector_variables['api_parms']['cursor'] = previous_state.get('cursor')

    def pull(self, retrieving_timestamp: datetime):
        """

        :param retrieving_timestamp:
        :return:
        """

        self.log_debug(f'Starting {self.name} pull()')

        total_indicators = 0
        expired = 0

        api_instance = self.collector_variables['api_instance']
        params = self.collector_variables['api_params']

        while True:
            api_response = api_instance.indicators_stream_get(**params)
            if not api_response.indicators:
                state = {'cursor': params['cursor']}
                self.persistence_object.save_state(state, no_log_traces=True)
                break
            total_indicators += len(api_response.indicators)
            for indicator in api_response.indicators:
                # Only parse and send unexpired indicators
                if indicator.data.expiration > int(datetime.now(timezone.utc).timestamp() * 1000):
                    self.parse_indicator(indicator)
                else:
                    expired += 1
            params['cursor'] = api_response.cursor_next

        self.log_debug(f'{total_indicators} indicators sent to output')
        self.log_debug(f'{expired} indicators not sent to output because expired')
        self.log_debug('Finalizing pull()')

    def pull_pause(self, wait: bool = None) -> None:
        """Not required for this collector"""
        pass

    def pull_stop(self) -> None:
        """Not required for this collector"""
        pass

    def check_status_code(self, code: str):
        """ Check response status code """
        # Check is user's TITAN credentials are configured correctly
        if code == '401':
            raise UnauthorisedException(401, 'Unauthorised. Please check your TITAN credentials (email and API key) are configured correctly.')
        # Check if user's is authorised to retrieve data from queried API endpoint
        elif code == '404':
            raise NoAccessException(404, 'No access to this feed. Please contact your CSR to enquire about this feed.')
        # Check if user has reached maximum API request limit
        elif code == '429':
            raise MaxLimitException(429, 'Maximum API request limit hit. Please wait to try again or contact your CSR to increase limit if usage requires.')

    def get_from_timestamp(self, ndays: int) -> int:
        """ Generate _from timestamp """
        now = datetime.now(tz=timezone.utc)
        today = datetime(year=now.year, month=now.month, day=now.day, tzinfo=timezone.utc)
        return int((today - timedelta(days=ndays)).timestamp() * 1000)

    def get_readable_date(self, epoch: int) -> str:
        return datetime.fromtimestamp(epoch / 1000).strftime('%-d %b %Y')

    def parse_indicator(self, indicator: IndicatorSearchSchema):
        """ Parse indicators for relevant data to send to Devo """
        try:
            indicator_type = indicator.data.indicator_type
            indicator_data = indicator.data.indicator_data

            malware_data = indicator.data.threat.data
            malware_family = malware_data.family
            malware_variant = malware_data.variant if malware_data.variant else 'n/a'
            malware_version = malware_data.version if malware_data.version else 'n/a'

            content = [
                indicator.uid,
                self.get_readable_date(indicator.activity.first),
                self.get_readable_date(indicator.activity.last),
                indicator_type,
                indicator.data.context.description,
                malware_family,
                malware_version,
                malware_variant,
                self.get_readable_date(indicator.data.expiration),
                indicator.data.confidence,
                indicator.data.mitre_tactics,
                ' / '.join(indicator.data.intel_requirements),
            ]

            if indicator_type == 'file':
                content += [
                    indicator_data.file.download_url,
                    indicator_data.file.md5,
                    indicator_data.file.sha1,
                    indicator_data.file.sha256,
                    indicator_data.file.ssdeep,
                    indicator_data.file.size,
                    indicator_data.file.type,
                ]
            elif indicator_type == 'ipv4':
                geo_ip = indicator_data.geo_ip
                if geo_ip:
                    content += [
                        indicator_data.address,
                        indicator_data.geo_ip.isp,
                        indicator_data.geo_ip.city if indicator_data.geo_ip.city else 'n/a',
                        indicator_data.geo_ip.country,
                    ]
                else:
                    content += [indicator_data.address, 'n/a', 'n/a', 'n/a']
            elif indicator_type == 'url':
                content += [indicator_data.url]

            self.send_to_devo(content, self.collector_variables['lookup_tables'][indicator_type])
        except AttributeError as e:
            self.log_error(f'Indicator with UID = {indicator.uid} encountered the following exception {e}')

    def send_to_devo(self, content: list, lookup_job_factory: LookupJobFactory):
        """ Send data to Devo """
        # Checking status
        status = self.collector_variables.get('status')
        log.info(f"Status -> {status}")

        if status is None:
            # Create the table in Devo
            rejected, _ = lookup_job_factory.add_item_to_list_to_initialize(content)
            self.__print_lookup_results(accepted=len(content)-rejected, rejected=rejected)
            self.send_lookup_messages(lookup_job_factory=lookup_job_factory, start=True, end=True, buffer='Create')
            self.collector_variables['status']: str = 'CREATED_LOOKUP_TABLE'
            log.info(f"New status -> {self.collector_variables['status']}")
        elif status == 'CREATED_LOOKUP_TABLE':
            # Modify the table in Devo
            rejected, _ = lookup_job_factory.add_item_to_list_to_modify(content)
            self.__print_lookup_results(accepted=len(content) - rejected, rejected=rejected)
            self.send_lookup_messages(lookup_job_factory=lookup_job_factory, start=True, end=True, buffer='Modify')
            self.collector_variables['status']: str = 'MODIFIED_LOOKUP_TABLE'
            log.info(f"New status -> {self.collector_variables['status']}")

    @staticmethod
    def __print_lookup_results(accepted: int, rejected: int):
        """
        Print lookup results
        @param accepted: Number of accepted items.
        @param rejected: Number of rejected items.
        """
        total = accepted + rejected
        log.info(f'Items sent to buffer: {total}')
        log.info(f'Items accepted by Lookup Factory: {accepted}')
        log.info(f'Items rejected by Lookup Factory: {rejected}')
