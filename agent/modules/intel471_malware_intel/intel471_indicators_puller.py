import logging
import time
from datetime import datetime, timedelta, timezone

from devocollectorsdk.inputs.collector_puller_abstract import CollectorPullerAbstract
from devocollectorsdk.message.lookup_job_factory import LookupJobFactory

# noinspection PyUnresolvedReferences
from agent.modules.intel471_malware_intel.intel471_indicators_puller_setup import Intel471IndicatorsPullerSetup
from agent.modules.intel471_malware_intel.exceptions.exceptions import *

log = logging.getLogger(__name__)

logging.getLogger('intel471_indicators_puller').setLevel(logging.WARNING)


class Intel471IndicatorsPuller(CollectorPullerAbstract):

    def init_variables(
            self,
            input_config: dict,
            input_definition: dict,
            service_config: dict,
            service_definition: dict,
            module_config: dict,
            module_definition: dict,
            submodule_config: dict):
        """

        :param input_config:
        :param input_definition:
        :param service_config:
        :param service_definition:
        :param module_config:
        :param module_definition:
        :param submodule_config:
        :return:
        """

        self.log_debug(f'{self.name} Starting the execution of init_variables()')

        # Initialization of properties from credentials section from configuration
        credentials: dict[str, str] = input_config.get('credentials')
        if credentials is None:
            raise CredentialException(1, f'Missing required "credentials" section in the configuration')

        username: str = credentials.get('username')
        if username is None:
            raise CredentialException(2, f'Missing required "username" property from "credentials" section in configuration')
        self.collector_variables['username'] = username

        password: str = credentials.get('password')
        if password is None:
            raise CredentialException(3,'Missing required "password" property from "credentials" section in configuration')
        self.collector_variables['password'] = password

        parameters: dict[str, int] = input_config.get('parameters')
        duration: int = parameters.get('duration')
        self.collector_variables['api_params']: dict = {
            'count': 100,
            '_from': self.get_from_timestamp(duration),
        }

        base_headers: list[str] = [
            'uid',
            'first_seen',
            'last_seen',
            'indicator_type',
            'indicator_data',
            'context',
            'malware_family',
            'malware_family_version',
            'malware_family_variant',
            'expiration',
            'confidence',
            'mitre_tactics',
            'gir'
        ]

        self.collector_variables['file_lookup_headers']: list[str] = base_headers + [
            'download_url',
            'md5',
            'sha1',
            'sha256',
            'ssdeep',
            'size',
            'type'
        ]
        self.collector_variables['file_lookup_field_types']: list[str] = ['str'] * len(self.collector_variables['file_lookup_headers'])

        self.collector_variables['ipv4_lookup_headers']: list[str] = base_headers + [
            'isp',
            'city',
            'country'
        ]
        self.collector_variables['ipv4_lookup_field_types']: list[str] = ['str'] * len(self.collector_variables['ipv4_lookup_headers'])
        self.collector_variables['ipv4_lookup_headers'][4] = 'ip4'  # set indicator_data field type to ip4

        self.collector_variables['url_lookup_headers']: list[str] = base_headers
        self.collector_variables['url_lookup_field_types']: list[str] = ['str'] * len(self.collector_variables['url_lookup_headers'])

        self.collector_variables['lookup_key']: str = 'uid'
        self.collector_variables['lookup_status']: str = None

        self.log_debug(f'{self.name} Finalizing the execution of init_variables()')

    def pre_pull(self, retrieving_timestamp: datetime):
        """
        :param retrieving_timestamp:
        :return:
        """

        log.info('[pre_pull] -> Creating a relevant lookup_job_factory to be used by the pull method')

        file_lookup_table: LookupJobFactory = LookupJobFactory(
            lookup_name='malware_file_indicators',
            headers=self.collector_variables['file_lookup_headers'],
            field_types=self.collector_variables['file_lookup_field_types'],
            key=self.collector_variables['lookup_key'],
            historic_tag=self.collector_variables['lookup_status']
        )

        ipv4_lookup_table: LookupJobFactory = LookupJobFactory(
            lookup_name='malware_ipv4_indicators',
            headers=self.collector_variables['ipv4_lookup_headers'],
            field_types=self.collector_variables['ipv4_lookup_field_types'],
            key=self.collector_variables['lookup_key'],
            historic_tag=self.collector_variables['lookup_status']
        )

        url_lookup_table: LookupJobFactory = LookupJobFactory(
            lookup_name='malware_url_indicators',
            headers=self.collector_variables['url_lookup_headers'],
            field_types=self.collector_variables['url_lookup_field_types'],
            key=self.collector_variables['lookup_key'],
            historic_tag=self.collector_variables['lookup_status']
        )

        self.collector_variables['file_lookup_table']: LookupJobFactory = file_lookup_table
        self.collector_variables['ipv4_lookup_table']: LookupJobFactory = ipv4_lookup_table
        self.collector_variables['url_lookup_table']: LookupJobFactory = url_lookup_table

    def pull(self, retrieving_timestamp: datetime):
        """

        :param retrieving_timestamp:
        :return:
        """

        self.log_debug(f'Starting {self.name} pull()')

        total_indicators = 0

        example_tag = 'my.app.if_framework.example_2'
        example_content = 'Example text from \"example_2\"'

        self.send_standard_message(datetime.utcnow(), example_tag, example_content)
        time.sleep(1)
        self.send_standard_message(datetime.utcnow(), example_tag, example_content)

        self.log_debug('Messages sent to output')

        self.log_debug('Finalizing pull()')

        # Checking status
        status = self.collector_variables.get('status')
        log.info(f"Status -> {status}")

        # Get the lookup_job_factory
        lookup_job_factory_1: LookupJobFactory = self.collector_variables['lookup_job_factory_1']

        if status is None:

            # Create the table in Devo
            content = self.collector_variables['content_to_create']
            rejected, details = lookup_job_factory_1.add_item_to_list_to_initialize(content)
            self.__print_lookup_results(accepted=len(content)-rejected, rejected=rejected)

            self.send_lookup_messages(lookup_job_factory=lookup_job_factory_1, start=True, end=True, buffer='Create')

            self.collector_variables['status']: str = 'CREATED_LOOKUP_TABLE'
            log.info(f"New status -> {self.collector_variables['status']}")

        elif status == 'CREATED_LOOKUP_TABLE':

            # Modify the table in Devo
            content = self.collector_variables['content_to_modify']
            rejected, details = lookup_job_factory_1.add_item_to_list_to_modify(content)
            self.__print_lookup_results(accepted=len(content) - rejected, rejected=rejected)

            self.send_lookup_messages(lookup_job_factory=lookup_job_factory_1, start=True, end=True, buffer='Modify')

            self.collector_variables['status']: str = 'MODIFIED_LOOKUP_TABLE'
            log.info(f"New status -> {self.collector_variables['status']}")

        else:

            # Remove the table in Devo
            content = self.collector_variables['content_to_remove']
            rejected, details = lookup_job_factory_1.add_item_to_list_to_remove(content)
            self.__print_lookup_results(accepted=len(content) - rejected, rejected=rejected)

            self.send_lookup_messages(lookup_job_factory=lookup_job_factory_1, start=True, end=True, buffer='Remove')

            self.collector_variables['status']: str = 'REMOVED_LOOKUP_TABLE'
            log.info(f"New status -> {self.collector_variables['status']}")

            # Terminate collector
            log.info("Demo job has been completed")
            log.info("running_flag has been updated to False")
            self.running_flag = False

    def check_status_code(self, code: str):
        """ Check response status code """
        # Check is user's TITAN credentials are configured correctly
        if code == '401':
            raise UnauthorisedException(401, 'Unauthorised. Please check your TITAN credentials (email and API key) are configured correctly.')
        # Check if user's is authorised to retrieve data from queried API endpoint
        elif code == '404':
            raise NoAccessException(404, 'No access to this feed. Please contact your CSR to enquire about this feed.')
        # Check if user has reached maximum API request limit
        elif code == '429':
            raise MaxLimitException(429, 'Maximum API request limit hit. Please wait to try again or contact your CSR to increase limit if usage requires.')

    def get_from_timestamp(self, ndays: int) -> int:
        """ Generate _from timestamp """
        now = datetime.now(tz=timezone.utc)
        today = datetime(year=now.year, month=now.month, day=now.day, tzinfo=timezone.utc)
        return int((today - timedelta(days=ndays)).timestamp() * 1000)
